%!TEX root = ../Thesis.tex

\section{Technologieentscheidungen}

\subsection*{Nicolas Groß}

Bei der Entwicklung des Frontend haben wir uns für das Ionic-Framework entschieden. Das Ionic-Framework ist ein Open-Source UI Toolkit für die Entwicklung von Hybrid-Apps. Hybrid-Apps sind Anwendungen, welche auf Web-Technologien wie HTML, CSS und JavaScript basieren und die nativen APIs und Funktionen des Betriebssystems nutzen können.\footcite[.vgl]{HybrideWebApp}  Ionic bietet Vorteile wie Performance-Optimierung, Cross-Plattform und die automatische Bereitstellung einer Hellen und Dunklen Ansicht.Ionic bietet zahlreiche anpassbare UI-Komponenten, welche helfen die Strukturierung und Gestaltung der Webanwendung vorzunehmen. Zudem bietet Ionic eine ausführliche Dokumentation und eine große Community, wodurch das Einbauen unbekannter Komponenten schnell und einfach ist. Ionic unterstützt neben dem klassischen JavaScript die Frameworks Angular, React und Vue.\footcite[.vgl]{Ionic2013}

Hierbei fiel unsere Entscheidung aus erfahrungsgründen auf Angular. Angular ist ein von Google entwickeltes auf TypeScript basierendes Open-Source Webframework zur Entwicklung von Mobile und Desktop Webanwendungen. Angular stellt ein Command-Line-Interface bereit, welches Entwicklern bei der Erstellung und Entwicklung der Projekte unterstützt. Die Entwicklung von Single-Page-Apps wird durch Angular Routing ermöglicht, wodurch Webanwendungen schneller auf Benutzereingaben reagieren und die Ladezeiten zwischen einzelnen Seiten stark vermindern. Zudem können Inhalte der Webseite dynamisch geladen und angepasst werden. Angular bietet genau wie Ionic eine ausführliche Dokumentation, Lehrunterlagen und eine aktive Community. Durch Angular ergibt sich die Möglichkeit umfangreiche Bibliotheken einzubinden und deren Ressourcen für die Entwicklung des Projektes zu nutzen.\footcite[.vgl]{Angular2016}

\subsection*{Datenbank (Niklas Hardes)}

Bei der Datenbank gab es diverse Möglichkeiten zu betrachten. Einerseits existieren die relationalen Datenbanken unter denen am bekanntesten die MySQL, PostgreSQL, MariaDB, Microsoft SQL Server und die Oracle Database sind. Eine relationale Datenbank ist dabei eine Sammlung von Informationen, welche Ihre Daten in Form von Tabellen mit Spalten und Zeilen speichert. Beziehungen sind hier vorab definiert. Neben den relationalen Datenbanken existieren die nicht relationalen Datenbanken. Diese werden auch NoSQL Datenbanken genannt. Die bekanntesten sind hier Apache Cassandra, Riak, MongoDB, Redis und CouchDB. Die relationalen Datenbanken eignen sich gut bei fest definierten Schemas und einer gewollten Stabilität und Sicherheit. Wohingegen nicht relationale Datenbanken kein fest definiertes Schema besitzen und so ein hohes Maß an Flexibilität bei Datenmodellen gewähren. Des Weiteren sind sie besser geeignet für riesige Datensätze und außerdem kostengünstiger im Aufbau und dem Betrieb. 

Im ersten Schritt haben wir uns dafür entschieden, eine nicht relationale Datenbank zu wählen. Dies einmal aus dem Grund, dass davon auszugehen ist, bei dem Sammeln aller aktuellen Preise von möglichst vielen Spielen bei möglichst vielen Händlern eine sehr große Menge an Daten anfällt. Der andere Grund ist eine gewollte Flexibilität. Eine detaillierte Datenbankmodellierung war zu Beginn nicht möglich. Die genauen Daten, welche wir von allen Händlern bekommen würden, mussten erst noch in Erfahrung gebracht werden. Mit der Zeit und dem dazu kommen von immer mehr Händlern muss die Datenbank sich daran anpassen können und gleichzeitig ermöglichen, dass sich nicht zu viel damit beschäftigt werden muss ein gesamtes Modell für die Datenbank anzulegen.

Unter den relationalen Datenbanken haben wir uns für eine MongoDB entschieden. Der Grund dafür ist, dass hier bereits eine große Instanz existierte, an die sich angeschlossen werden konnte. Diese Instanz besteht aus mehreren Nodes, was für Datensicherheit sorgt, und aus SSDs mit einem sehr hohen Durchsatz. Dadurch konnten wir ohne jedwede Kosten eine hochperformante Lösung benutzen.

\subsection*{Docker (Robert Hesselmann)}

Bei der Planung unseres Softwaresystems haben wir uns für Docker als Laufzeitumgebung entschieden. Dadurch kann unsere Software auf allen System laufen die Docker unterstützen. Der Ablauf vom Push eines Commits bis zum Deploy der Software, geht durch unsere \gls{CICD}, die Software wird Schritt für Schritt Compiliert, Analysiert und in ein Docker-Image verpackt, welches im letzten Schritt auf unseren Server ausgespielt wird.

Der Vorteil von Docker ist, dass Docker in Isolierten Containern arbeitet. Somit bekommen andere Container nicht davon mit wird ein andere Container erstellt oder das der Container eine Berechnung macht. Ein weiterer Vorteil von Docker sind die universell einsetzbaren Images. Diese Images bilden einen Standard ab. Somit kann ein beliebiges Image auf jeder Plattform eingesetzt werden.
